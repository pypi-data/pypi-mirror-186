# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['compact_json']

package_data = \
{'': ['*']}

install_requires = \
['wcwidth>=0.2.5,<0.3.0']

entry_points = \
{'console_scripts': ['compact-json = compact_json._compact_json:main']}

setup_kwargs = {
    'name': 'compact-json',
    'version': '1.5.0',
    'description': 'A JSON formatter that produces compact but human-readable',
    'long_description': '# compact-json\n\n[![build:](https://github.com/masaccio/compact-json/actions/workflows/run-all-tests.yml/badge.svg)](https://github.com/masaccio/compact-json/actions/workflows/run-all-tests.yml)\n[![build:](https://github.com/masaccio/compact-json/actions/workflows/codeql.yml/badge.svg)](https://github.com/masaccio/compact-json/actions/workflows/codeql.yml)\n[![codecov](https://codecov.io/gh/masaccio/compact-json/branch/main/graph/badge.svg?token=EKIUFGT05E)](https://codecov.io/gh/masaccio/compact-json)\n\n`compact-json` is a JSON formatter that produces configurably compact JSON that remains human-readable.\n\nAny given container is formatted in one of three ways:\n\n* Python lists or dicts will be written on a single line, if their contents aren\'t too complex and the resulting line wouldn\'t be too long.\n* lists can be written on multiple lines, with multiple items per line, as long as those items aren\'t too complex.\n* Otherwise, each dict property or array item is written beginning on its own line, indented one step deeper than its parent.\n\nThe following JSON is the standard output from running `python3 -mjson.tool`:\n\n``` JSON\n{\n    "widget": {\n        "debug": "on",\n        "window": {\n            "title": "Sample Konfabulator Widget",\n            "name": "main_window",\n            "width": 500,\n            "height": 500\n        },\n        "image": {\n            "src": "Images/Sun.png",\n            "name": "sun1",\n            "hOffset": 250,\n            "vOffset": 250,\n            "alignment": "center"\n        },\n        "text": {\n            "data": "Click Here",\n            "size": 36,\n            "style": "bold",\n            "name": "text1",\n            "hOffset": 250,\n            "vOffset": 100,\n            "alignment": "center",\n            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"\n        }\n    }\n}\n```\n\nThe `window` and `image` objects are fairly short so when formatted with `compact-json` they can be formated on a single line. With the default setting the `text` object is still too long to fit on one line, but this can be configured to be longer:\n\n``` JSON\n{\n    "widget": {\n        "debug": "on",\n        "window": {"title": "Sample Konfabulator Widget", "name": "main_window", "width": 500, "height": 500},\n        "image": {"src": "Images/Sun.png", "name": "sun1", "hOffset": 250, "vOffset": 250, "alignment": "center"},\n        "text": {\n            "data": "Click Here",\n            "size": 36,\n            "style": "bold",\n            "name": "text1",\n            "hOffset": 250,\n            "vOffset": 100,\n            "alignment": "center",\n            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"\n        }\n    }\n}\n```\n\n## Installation\n\n``` shell\npython3 -m pip install compact-json\n```\n\n## Usage\n\nAs a python package, `compact-json` is instantiated with a `Formatter` class that has a range of properties to configure the formatting:\n\n``` python\nfrom compact_json import Formatter, EolStyle\n\nformatter = Formatter()\nformatter.indent_spaces = 2\nformatter.max_inline_complexity = 10\nformatter.json_eol_style = EolStyle.LF\n\nwith open("input.json", "r") as f:\n    obj = json.load(f)\n    json_string = formatter.serialize(obj)\n    print(json_string)\n```\n\n## Runtime warnings\n\nUnlike the builtin `json` package, `compact-json` will issue runtime warnings when dictionary keys are forced to strings or overwritten to ensure that the resulting JSON is well-formed:\n\n``` python\n>>> from compact_json import Formatter\n>>> Formatter().serialize({100: "error", 200: "had", 300: ["a", "little", "lamb"], "100": "mary"})\n/path/src/compact_json/formatter.py:346: RuntimeWarning: coercing key value 100 to string\n  warnings.warn(f"converting key value {k} to string", RuntimeWarning)\n/path/src/compact_json/formatter.py:346: RuntimeWarning: coercing key value 200 to string\n  warnings.warn(f"converting key value {k} to string", RuntimeWarning)\n/path/src/compact_json/formatter.py:346: RuntimeWarning: coercing key value 300 to string\n  warnings.warn(f"converting key value {k} to string", RuntimeWarning)\n/path/src/compact_json/formatter.py:349: RuntimeWarning: duplicate key value 100\n  warnings.warn(f"duplicate key value {k}", RuntimeWarning)\n\'{ "100": "mary", "200": "had", "300": ["a", "little", "lamb"] }\'\n```\n\n## Command-line usage\n\nWhen installed from `pip` a command-line utility `compact-json` is installed which has some useful defaults and most of the parameters available in `Formatter` can be set on the command-line:\n\n``` shell\nusage: _compact_json.py [-h] [-V] [--crlf] [--max-inline-length N]\n                        [--max-inline-complexity N]\n                        [--max-compact-list-complexity N]\n                        [--bracket-padding {simple,nested}] [--indent N]\n                        [--tab-indent] [--justify-numbers]\n                        [--prefix-string STRING] [--align-properties]\n                        [json ...]\n\nFormat JSON into compact, human readble form\n\npositional arguments:\n  json                  JSON file(s) to parse (or stdin with "-")\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version\n  --crlf                Use Windows-style CRLR line endings\n  --max-inline-length N\n                        Limit inline elements to N chars, excluding\n                        indentation and leading property names (default=50)\n  --max-inline-complexity N\n                        Maximum nesting: 0=basic types, 1=dict/list, 2=all\n                        (default=2)\n  --max-compact-list-complexity N\n                        Maximum nesting over multiple lines (default 1)\n  --bracket-padding {simple,nested}\n                        If nested padding, add speces inside outside brackes\n                        for nested lists/dicts\n  --indent N            Indent N spaces (default=4)\n  --tab-indent          Use tabs to indent\n  --justify-numbers     Right-align numbers with matching precision\n  --prefix-string STRING\n                        String attached to the beginning of every line\n  --align-properties    Align property names of expanded dicts\n  --unicode             Treat strings as unicode East Asian characters\n```\n\n`compact-json` can be used in a shell pipeline to read from stdin when passed `-` as the file argument.\n\n## Format options\n\nThe `Formatter` class has the following properties:\n\n### `json_eol_style`\n\nDictates what sort of line endings to use. `EolStyle.LF` is Unix-style line endings (the default) and `EolStyle.CRLF` Windows-style.\n\n### `max_inline_length`\n\nMaximum length of a complex element on a single line. This includes only the data for the inlined element not indentation or leading property names. The default is 80.\n\n### `max_inline_complexity`\n\nMaximum nesting level that can be displayed on a single line. A primitive type or an empty list or dict has a complexity of 0. A dict or list has a complexity of 1 greater than its most complex child. The default is 2.\n\n### `max_compact_list_complexity`\n\nMaximum nesting level that can be arranged spanning multiple lines, with multiple items per line. The default is 1.\n\n### `nested_bracket_padding`\n\nIf an inlined list or dict contains other lists or dicts, setting `nested_bracket_padding` to `True` will include spaces inside the outer brackets. The default is `True`.\n\nSee also `simple_bracket_padding`.\n\n### `simple_bracket_padding`\n\nIf an inlined list or dict does NOT contain other lists/dicts, setting `simple_bracket_padding` to `True` will include spaces inside the brackets. The default is `False`.\n\nSee also `nested_bracket_padding`.\n\n### `colon_padding`\n\nIf `True` (the default), includes a space after property colons.\n\n### `comma_padding`\n\nIf `True` (the default), includes a space after commas separating list items and dict properties.\n\n### `always_expand_depth`\n\nDepth at which lists/dicts are always fully expanded, regardless of other settings\n\n* -1 = none. This is the default\n* 0 = root node only\n* 1 = root node and its children.\n\n### `indent_spaces`\n\nNumber of spaces to use per indent level (unless `use_tab_to_indent` is `True`). The default is 4.\n\n### `use_tab_to_indent`\n\nUses a single tab per indent level, instead of spaces. The default is `False`.\n\n### `table_dict_minimum_similarity`\n\nValue from 0 to 100 indicating how similar collections of inline dicts need to be to be formatted as a table. A group of dicts that don\'t have any property names in common has a similarity of zero. A group of dicts that all contain the exact same property names has a similarity of 100. Setting this to a value > 100 disables table formatting with dicts as rows. The default is 75.\n\n### `table_list_minimum_similarity`\n\nValue from 0 to 100 indicating how similar collections of inline lists need to be to be formatted as a table. Similarity for lists refers to how similar they are in length; if they all have the same length their similarity is 100. Setting this to a value > disables table formatting with lists as rows. The default is 75.\n\n### `align_expanded_property_names`\n\nIf `True`, property names of expanded dicts are padded to the same size. The default is `False`.\n\n### `dont_justify_numbers`\n\nIf `True`, numbers won\'t be right-aligned with matching precision. The default is `False`.\n\n### `prefix_string`\n\nString attached to the beginning of every line, before regular indentation.\n\n### `ensure_ascii`\n\nIf `True` (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If `ensure_ascii` is `False`, these characters will be output as-is.\n\n### `east_asian_string_widths`\n\nIf `True`, format strings using unicodedata.east_asian_width rather than simple string lengths\n\n## Credits\n\n`compact-json` is primarily a Python port of [FracturedJsonJs](https://github.com/j-brooke/FracturedJsonJs) by [j-brooke](https://github.com/j-brooke). FractureJson is also\nan excellent [Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=j-brooke.fracturedjsonvsc). This package has no other relationship\nwith this original code, and hence all the bugs are my own.\n\n## License\n\nAll code in this repository is licensed under the [MIT License](https://github.com/masaccio/compact-json/blob/master/LICENSE.rst)\n\n## Contribute\n\nContributions are greatly appreciated and welcomed. Please follow the [project guidance](CONTRIBUTING.md) on how to contribute.\n',
    'author': 'Jon Connell',
    'author_email': 'python@figsandfudge.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/masaccio/compact-json',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
