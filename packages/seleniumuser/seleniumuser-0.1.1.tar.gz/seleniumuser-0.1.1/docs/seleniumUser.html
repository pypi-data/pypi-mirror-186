<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>seleniumUser.seleniumUser API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seleniumUser.seleniumUser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import random
import sys
import time
from pathlib import Path
from types import LambdaType
from typing import Any
from warnings import warn

from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.firefox.firefox_profile import FirefoxProfile
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.support.ui import Select

from noifTimer import Timer
from voxScribe import getTextFromUrl
from whosYourAgent import getAgent


class User:
    &#34;&#34;&#34;Sits on top of selenium to streamline
    automation and scraping tasks.&#34;&#34;&#34;

    def __init__(
        self,
        headless: bool = False,
        browserType: str = &#34;firefox&#34;,
        implicitWait: int = 10,
        pageLoadTimeout: int = 60,
        openBrowser: bool = True,
        locatorMethod: str = &#34;xpath&#34;,
        randomizeUserAgent: bool = True,
        userAgentRotationPeriod: int = None,
        moveWindowBy: tuple[int, int] = (0, -1000),
        downloadDir: str | Path = None,
        driverPath: str | Path = None,
    ):
        &#34;&#34;&#34;
        :param headless: If True, browser window will not be visible.

        :param browserType: Which browser to use. Can be &#39;firefox&#39; or &#39;chrome&#39;.

        :param implicitWait: Number of seconds to look for a specified element before
        selenium considers it missing and throws an exception.

        :param pageLoadTimeout: Time in seconds for selenium to wait for a page to load
        before throwing an exception.

        :param openBrowser: If True, opens a browser window when a User object is created.
        If False, a manual call to self.openBrowser() must be made.

        :param locatorMethod: The locator type User should expect to be given.
        Can be &#39;xpath&#39;, &#39;id&#39;, &#39;className&#39;, &#39;name&#39;, or &#39;cssSelector&#39;.
        Every member function with a &#39;locator&#39; argument refers to a string matching
        the current locatorMethod.

        :param randomizeUserAgent: If True, a random useragent will be used whenever
        the browser is opened. If False, the native useragent will be used.

        :param userAgentRotationPeriod: If not None, the browser window will be closed
        and reopened with a new useragent every userAgentRotationPeriod number of minutes.
        Rotation occurs on the first call to self.get() after the time period has elapsed.
        Ignored if randomizeUserAgent is False.

        :param moveWindowBy: The x and y amount of pixels to move the browser window by after opening.

        :param downloadDir: The download folder to use. If None, the default folder will be used.

        :param driverPath: The path to the webdriver executable selenium should use.
        If None, the system PATH will be checked for the executable.
        If the executable isn&#39;t found, the parent directories and the immediate child directories
        of the current working directory will be searched.
        &#34;&#34;&#34;
        self.headless = headless
        browserType = browserType.lower()
        if browserType in [&#34;firefox&#34;, &#34;chrome&#34;]:
            self.browserType = browserType
        else:
            raise ValueError(&#34;&#39;browserType&#39; parameter must be &#39;firefox&#39; or &#39;chrome&#39;&#34;)
        self.browserOpen = False
        self.implicitWait = implicitWait
        self.pageLoadTimeout = pageLoadTimeout
        self.rotationTimer = Timer()
        self.timer = Timer()
        self.timer.start()
        self.randomizeUserAgent = randomizeUserAgent
        self.userAgentRotationPeriod = userAgentRotationPeriod
        self.locatorMethod = locatorMethod
        self.turbo()
        self.keys = Keys
        self.moveWindowBy = moveWindowBy
        self.downloadDir = downloadDir
        self.driverPath = driverPath
        if not self.driverPath:
            self.searchForDriver()
        if openBrowser:
            self.openBrowser()
        else:
            self.browser = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.closeBrowser()

    def configureFirefox(self) -&gt; FirefoxService:
        &#34;&#34;&#34;Configure options and profile for firefox.&#34;&#34;&#34;
        self.options = FirefoxOptions()
        self.options.headless = self.headless
        self.options.set_preference(
            &#34;widget.windows.window_occlusion_tracking.enabled&#34;, False
        )
        self.options.set_preference(&#34;dom.webaudio.enabled&#34;, False)
        if self.randomizeUserAgent:
            self.options.set_preference(&#34;general.useragent.override&#34;, getAgent())
        if self.downloadDir:
            Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
            self.profile = FirefoxProfile()
            self.profile.set_preference(&#34;browser.download.dir&#34;, str(self.downloadDir))
            self.profile.set_preference(&#34;browser.download.folderList&#34;, 2)
        else:
            self.profile = None
        self.service = FirefoxService(
            executable_path=str(self.driverPath), log_path=os.devnull
        )

    def configureChrome(self) -&gt; ChromeService:
        &#34;&#34;&#34;Configure options and profile for chrome.&#34;&#34;&#34;
        self.options = ChromeOptions()
        self.options.headless = self.headless
        self.options.add_argument(&#34;--disable-blink-features=AutomationControlled&#34;)
        self.options.add_argument(&#34;--mute-audio&#34;)
        self.options.add_argument(&#34;--disable-infobars&#34;)
        self.options.add_argument(&#34;--disable-notifications&#34;)
        self.options.add_argument(&#34;--log-level=3&#34;)
        if self.randomizeUserAgent:
            self.options.add_argument(f&#34;--user-agent={getAgent()}&#34;)
        self.options.add_experimental_option(&#34;useAutomationExtension&#34;, False)
        if self.downloadDir:
            Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
            self.options.add_experimental_option(
                &#34;prefs&#34;, {&#34;download.default_directory&#34;: str(self.downloadDir)}
            )
        self.service = ChromeService(
            executable_path=str(self.driverPath), log_path=os.devnull
        )

    def searchForDriver(self):
        &#34;&#34;&#34;Searches for the webdriver executable.&#34;&#34;&#34;
        cwd = Path.cwd()
        found = False
        match self.browserType:
            case &#34;firefox&#34;:
                driver = &#34;geckodriver.exe&#34;
            case &#34;chrome&#34;:
                driver = &#34;chromedriver.exe&#34;
        # search PATH
        envPath = os.environ[&#34;PATH&#34;]
        if sys.platform == &#34;win32&#34;:
            envPaths = envPath.split(&#34;;&#34;)
        else:
            envPaths = envPath.split(&#34;:&#34;)
            driver = driver[: driver.find(&#34;.&#34;)]
        for path in envPaths:
            if (Path(path) / driver).exists():
                self.driverPath = Path(path) / driver
                found = True
                break
        # check current working directory and parent folders
        if not found:
            while cwd != cwd.parent:
                if (cwd / driver).exists():
                    self.driverPath = cwd / driver
                    found = True
                    break
                cwd = cwd.parent
            # check top most level
            if not found and (cwd / driver).exists():
                self.driverPath = cwd / driver
                found = True
        # check child folders (only 1 level down)
        if not found:
            for child in Path.cwd().iterdir():
                if child.is_dir() and (child / driver).exists():
                    self.driverPath = child / driver
                    found = True
        if not found:
            warn(f&#34;Could not find {driver}&#34;)

    def setImplicitWait(self, waitTime: int = None):
        &#34;&#34;&#34;Sets to default time if no arg given.&#34;&#34;&#34;
        if not waitTime:
            self.browser.implicitly_wait(self.implicitWait)
        else:
            self.browser.implicitly_wait(waitTime)

    def openBrowser(self):
        &#34;&#34;&#34;Configures and opens selenium browser.&#34;&#34;&#34;
        if not self.browserOpen:
            match self.browserType:
                case &#34;firefox&#34;:
                    self.configureFirefox()
                    self.browser = webdriver.Firefox(
                        options=self.options,
                        service=self.service,
                        firefox_profile=self.profile,
                    )
                case &#34;chrome&#34;:
                    self.configureChrome()
                    self.browser = webdriver.Chrome(
                        options=self.options, service=self.service
                    )
            self.setImplicitWait()
            self.browser.maximize_window()
            self.browser.set_window_position(self.moveWindowBy[0], self.moveWindowBy[1])
            self.browser.maximize_window()
            self.browser.set_page_load_timeout(self.pageLoadTimeout)
            self.browserOpen = True
            self.tabIndex = 0
            self.rotationTimer.start()
        else:
            warn(&#34;Browser already open.&#34;)

    def closeBrowser(self):
        &#34;&#34;&#34;Close browser window.&#34;&#34;&#34;
        self.browserOpen = False
        self.browser.quit()

    def openTab(self, url: str = &#34;&#34;, switchToTab: bool = True):
        &#34;&#34;&#34;Opens new tab and, if provided, goes to url.

        New tab is inserted after currently active tab.&#34;&#34;&#34;
        self.script(&#34;window.open(arguments[0]);&#34;, url)
        if switchToTab:
            self.switchToTab(self.tabIndex + 1)

    def switchToTab(self, tabIndex: int):
        &#34;&#34;&#34;Switch to a tab in browser, zero indexed.&#34;&#34;&#34;
        self.browser.switch_to.window(self.browser.window_handles[tabIndex])
        self.tabIndex = tabIndex

    def getNumTabs(self) -&gt; int:
        &#34;&#34;&#34;Returns number of tabs open.&#34;&#34;&#34;
        return len(self.browser.window_handles)

    def closeTab(self, tabIndex: int = 1):
        &#34;&#34;&#34;Close specified tab and
        switches to tab index 0.&#34;&#34;&#34;
        self.switchToTab(tabIndex)
        self.browser.close()
        self.switchToTab(0)

    def get(self, url: str):
        &#34;&#34;&#34;Requests webpage at given url and rotates userAgent if necessary.&#34;&#34;&#34;
        if not self.browserOpen:
            self.openBrowser()
        if (
            self.randomizeUserAgent
            and self.userAgentRotationPeriod is not None
            and self.rotationTimer.check(format=False)
            &gt; (60 * self.userAgentRotationPeriod)
        ):
            self.rotationTimer.stop()
            self.closeBrowser()
            self.openBrowser()
        self.browser.get(url)
        self.script(&#34;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; false})&#34;)
        self.chill(self.arrivalWait)

    def getSoup(self) -&gt; BeautifulSoup:
        &#34;&#34;&#34;Returns a BeautifulSoup object
        of the current page source.&#34;&#34;&#34;
        return BeautifulSoup(self.browser.page_source, &#34;html.parser&#34;)

    def currentUrl(self) -&gt; str:
        &#34;&#34;&#34;Returns current url of active tab.&#34;&#34;&#34;
        return self.browser.current_url

    def deleteCookies(self):
        &#34;&#34;&#34;Delete all cookies for
        this browser instance.&#34;&#34;&#34;
        self.browser.delete_all_cookies()

    def turbo(self, engage: bool = True):
        &#34;&#34;&#34;When engaged, strings will be sent
        to elements all at once and there will be
        no waiting after actions.

        When disengaged, strings will be sent to elements
        &#39;one key at a time&#39; with randomized amounts of
        time between successive keys and after actions.&#34;&#34;&#34;
        if engage:
            self.afterKeyWait = (0, 0)
            self.afterFieldWait = (0, 0)
            self.afterClickWait = (0, 0)
            self.arrivalWait = (1, 1)
            self.oneKeyAtATime = False
            self.turboEngaged = True
        else:
            self.afterKeyWait = (0.1, 0.5)
            self.afterFieldWait = (1, 2)
            self.afterClickWait = (0.25, 1.5)
            self.arrivalWait = (4, 10)
            self.oneKeyAtATime = True
            self.turboEngaged = False

    def chill(self, minMax: tuple[float, float]):
        &#34;&#34;&#34;Sleeps a random amount
        between minMax[0] and minMax[1].&#34;&#34;&#34;
        time.sleep(random.uniform(minMax[0], minMax[1]))

    def script(self, script: str, args: Any = None) -&gt; Any:
        &#34;&#34;&#34;Execute javascript code and returns result.&#34;&#34;&#34;
        return self.browser.execute_script(script, args)

    def remove(self, locator: str):
        &#34;&#34;&#34;Removes element from DOM.&#34;&#34;&#34;
        self.script(&#34;arguments[0].remove();&#34;, self.find(locator))

    def getLength(self, locator: str) -&gt; int:
        &#34;&#34;&#34;Returns number of child elements for a given element.&#34;&#34;&#34;
        return int(self.script(&#34;return arguments[0].length;&#34;, self.find(locator)))

    def find(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Finds and returns a WebElement.&#34;&#34;&#34;
        match self.locatorMethod:
            case &#34;xpath&#34;:
                return self.browser.find_element(By.XPATH, locator)
            case &#34;id&#34;:
                return self.browser.find_element(By.ID, locator)
            case &#34;className&#34;:
                return self.browser.find_element(By.CLASS_NAME, locator)
            case &#34;name&#34;:
                return self.browser.find_element(By.NAME, locator)
            case &#34;cssSelector&#34;:
                return self.browser.find_element(By.CSS_SELECTOR, locator)

    def findChildren(self, locator: str) -&gt; list[WebElement]:
        &#34;&#34;&#34;Returns a list of child WebElements
        for given locator arg.&#34;&#34;&#34;
        element = self.find(locator)
        return element.find_elements(&#34;xpath&#34;, &#34;./*&#34;)

    def scroll(self, amount: int = None, fraction: float = None):
        &#34;&#34;&#34;Scroll web page.
        :param amount: The number of lines to scroll if not None.

        :param fraction: The amount between 0.0 and 1.0
        of the page height to scroll.

        If values are provided for both arguments,
        amount will be used.

        If values are provided for neither argument,
        the entire page length will be scrolled.

        Scrolls one line at a time if self.turbo is False.&#34;&#34;&#34;
        if amount:
            amountToScroll = amount
        elif fraction:
            amountToScroll = int(
                fraction
                * (
                    int(self.script(&#34;return document.body.scrollHeight;&#34;))
                    - int(self.script(&#34;return window.pageYOffset;&#34;))
                )
            )
        else:
            amountToScroll = int(self.script(&#34;return document.body.scrollHeight;&#34;))
        if self.turboEngaged:
            self.script(&#34;window.scrollBy(0,arguments[0]);&#34;, amountToScroll)
        else:
            for _ in range(abs(amountToScroll)):
                if amountToScroll &gt;= 0:
                    self.script(&#34;window.scrollBy(0,1);&#34;)
                else:
                    self.script(&#34;window.scrollBy(0,-1);&#34;)
        self.chill(self.afterClickWait)

    def scrollIntoView(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Scrolls to a given element and returns the element.&#34;&#34;&#34;
        element = self.find(locator)
        self.script(&#34;arguments[0].scrollIntoView();&#34;, element)
        self.chill(self.afterClickWait)
        return element

    def text(self, locator: str) -&gt; str:
        &#34;&#34;&#34;Returns text of WebElement.&#34;&#34;&#34;
        return self.find(locator).text

    def click(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Clicks on and returns WebElement.&#34;&#34;&#34;
        element = self.find(locator)
        element.click()
        self.chill(self.afterClickWait)
        return element

    def clear(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Clears content of WebElement if able
        and then returns WebElement.&#34;&#34;&#34;
        element = self.find(locator)
        element.clear()
        self.chill(self.afterClickWait)
        return element

    def switchToIframe(self, locator: str):
        &#34;&#34;&#34;Switch to an iframe from given locator.&#34;&#34;&#34;
        self.browser.switch_to.frame(self.find(locator))

    def switchToParentFrame(self):
        &#34;&#34;&#34;Move up a frame level from current frame.&#34;&#34;&#34;
        self.browser.switch_to.parent_frame()

    def select(
        self, locator: str, method: str, choice: str | int | tuple
    ) -&gt; WebElement:
        &#34;&#34;&#34;Select a choice from Select element.
        Returns the Select element from the locator string,
        not the option element that is selected.

        :param method: Can be &#39;value&#39; or &#39;index&#39;

        :param choice: The option to select.

        If method is &#39;value&#39;, then choice should be
        the html &#39;value&#39; attribute of the desired option.

        If method is &#39;index&#39;, choice can either be a single
        int for the desired option or it can be a two-tuple.
        If the tuple is provided, a random option between the
        two indicies (inclusive) will be selected.&#34;&#34;&#34;
        element = self.click(locator)
        match method:
            case &#34;value&#34;:
                Select(element).select_by_value(choice)
            case &#34;index&#34;:
                if type(choice) == tuple:
                    choice = random.randint(choice[0], choice[1])
                Select(element).select_by_index(choice)
        self.chill(self.afterFieldWait)
        return element

    def clickElements(
        self, locators: list[str], maxSelections: int = None, minSelections: int = 1
    ) -&gt; WebElement:
        &#34;&#34;&#34;Click a random number of WebElements
        and return the last WebElement clicked.

        :param locators: A list of element locators to choose from.

        :param maxSelections: The maximum number of elements to click.
        If None, the maximum will be the length of the locators list.

        :param minSelections: The minimum number of elements to click.

        e.g. self.clickElements([xpath1, xpath2, xpath3, xpath4], maxSelections=3)
        will click between 1 and 3 random elements from the list.
        &#34;&#34;&#34;
        if not maxSelections:
            maxSelections = len(locators)
        for option in random.sample(
            locators, k=random.randint(minSelections, maxSelections)
        ):
            element = self.click(option)
        return element

    def getClickList(
        self, numOptions: int, maxChoices: int = 1, minChoices: int = 1
    ) -&gt; list[str]:
        &#34;&#34;&#34;Similar to self.clickElements(), but for use with the self.fillNext() method.

        Creates a list of length &#39;numOptions&#39; where every element is &#39;skip&#39;.

        A random number of elements in the list between &#39;minChoices&#39; and &#39;maxChoices&#39; are
        replaced with &#39;keys.SPACE&#39; (interpreted as a click by almost all web forms).&#34;&#34;&#34;
        clickList = [&#34;skip&#34;] * numOptions
        selectedIndexes = []
        for i in range(random.randint(minChoices, maxChoices)):
            index = random.randint(0, numOptions - 1)
            while index in selectedIndexes:
                index = random.randint(0, numOptions - 1)
            selectedIndexes.append(index)
            clickList[index] = self.keys.SPACE
        return clickList

    def sendKeys(
        self, locator: str, data: str, clickFirst: bool = True, clearFirst: bool = False
    ) -&gt; WebElement:
        &#34;&#34;&#34;Types data into element and returns the element.

        :param data: The string to send to the element.

        :param clickFirst: If True, the element is clicked on
        before the data is sent.

        :param clearFirst: If True, the current text of the element
        is cleared before the data is sent.&#34;&#34;&#34;
        element = self.click(locator) if clickFirst else self.find(locator)
        if clearFirst:
            element.clear()
            self.chill(self.afterClickWait)
        if self.oneKeyAtATime:
            for ch in str(data):
                element.send_keys(ch)
                self.chill(self.afterKeyWait)
        else:
            element.send_keys(str(data))
        self.chill(self.afterFieldWait)
        return element

    def fillNext(
        self, data: list[str | tuple], startElement: WebElement = None
    ) -&gt; WebElement:
        &#34;&#34;&#34;Fills a form by tabbing from the current WebElement
        to the next one and using the corresponding item in data.
        Returns the last WebElement.

        :param data: A list of form data. If an item is a string (except for &#39;skip&#39;)
        it will be typed into the current WebElement.

        An item in data can be a two-tuple of the form
        (&#39;downArrow&#39;, numberOfPresses:int|tuple[int, int]).

        If numberOfPresses is a single int, Keys.ARROW_DOWN will be sent
        that many times to the WebElement.

        If numberOfPresses is a tuple, Keys.ARROW_DOWN will be sent a random
        number of times between numberOfPresses[0] and numberOfPresses[1] inclusive.
        This is typically for use with Select elements.

        An item in data can also be &#39;skip&#39;, which will perform no action on the current
        WebElement and will continue to the next one.

        :param startElement: The WebElement to start tabbing from.
        The currently active element will be used if startElement is None.

        Note: The function tabs to the next element before sending data,
        so the startElement should the WebElement before the one
        that should receive data[0].
        &#34;&#34;&#34;
        element = (
            self.browser.switch_to.active_element if not startElement else startElement
        )
        for datum in data:
            element.send_keys(Keys.TAB)
            element = self.browser.switch_to.active_element
            self.chill(self.afterKeyWait)
            if datum[0] == &#34;downArrow&#34;:
                if type(datum[1]) == tuple:
                    times = random.randint(datum[1][0], datum[1][1])
                else:
                    times = datum[1]
                for _ in range(times):
                    element.send_keys(Keys.ARROW_DOWN)
                    self.chill(self.afterKeyWait)
            elif datum == &#34;skip&#34;:
                self.chill(self.afterKeyWait)
            else:
                if self.turboEngaged:
                    element.send_keys(str(datum))
                else:
                    for ch in str(datum):
                        element.send_keys(ch)
                        self.chill(self.afterKeyWait)
            self.chill(self.afterFieldWait)
        return element

    def waitUntil(
        self, condition: LambdaType, maxWait: float = 10, pollingInterval: float = 0.1
    ):
        &#34;&#34;&#34;Checks condition repeatedly until either it is true,
        or the maxWait is exceeded.

        Raises a TimeoutError if the condition doesn&#39;t success within maxWait.

        Useful for determing whether a form has been successfully submitted.

        :param condition: The condition function to check.

        :param maxWait: Number of seconds to continue checking condition
        before throwing a TimeoutError.

        :param pollingInterval: The number of seconds to sleep before
        checking the condition function again after it fails.

        e.g. self.waitUntil(lambda: &#39;Successfully Submitted&#39; in self.text(&#39;//p[@id=&#34;form-output&#34;]))&#34;&#34;&#34;
        startTime = time.time()
        while True:
            try:
                if condition():
                    time.sleep(1)
                    break
                elif (time.time() - startTime) &gt; maxWait:
                    raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
                else:
                    time.sleep(pollingInterval)
            except:
                if (time.time() - startTime) &gt; maxWait:
                    raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
                else:
                    time.sleep(pollingInterval)

    def dismissAlert(self):
        &#34;&#34;&#34;Dismiss alert dialog.&#34;&#34;&#34;
        self.browser.switch_to.alert.dismiss()

    def solveRecaptchaV3(
        self,
        outerIframeXpath: str = &#39;//iframe[@title=&#34;reCAPTCHA&#34;]&#39;,
        innerIframeXpath: str = &#39;//iframe[@title=&#34;recaptcha challenge expires in two minutes&#34;]&#39;,
    ):
        &#34;&#34;&#34;Pass google recaptcha v3 by solving an audio puzzle.

        :param outerIframeXpath: Xpath to the iframe containing the recaptcha checkbox.
        If it&#39;s the recaptcha without the initial checkbox that just shows the image puzzle,
        pass None to this argument.

        &#34;&#34;&#34;
        locatorMethod = self.locatorMethod
        self.locatorMethod = &#34;xpath&#34;
        try:
            if outerIframeXpath:
                self.switchToIframe(outerIframeXpath)
                self.click(&#39;//*[@id=&#34;recaptcha-anchor&#34;]&#39;)
                self.switchToParentFrame()
            self.switchToIframe(innerIframeXpath)
            self.click(&#39;//*[@id=&#34;recaptcha-audio-button&#34;]&#39;)
            mp3Url = self.find(
                &#39;//a[@class=&#34;rc-audiochallenge-tdownload-link&#34;]&#39;
            ).get_attribute(&#34;href&#34;)
            text = getTextFromUrl(mp3Url, &#34;.mp3&#34;)
            self.sendKeys(&#39;//*[@id=&#34;audio-response&#34;]&#39;, text)
            self.click(&#39;//*[@id=&#34;recaptcha-verify-button&#34;]&#39;)
        except Exception as e:
            print(e)
            raise Exception(&#34;Could not solve captcha&#34;)
        finally:
            self.switchToParentFrame()
            self.locatorMethod = locatorMethod</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="seleniumUser.seleniumUser.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
<span>(</span><span>headless: bool = False, browserType: str = 'firefox', implicitWait: int = 10, pageLoadTimeout: int = 60, openBrowser: bool = True, locatorMethod: str = 'xpath', randomizeUserAgent: bool = True, userAgentRotationPeriod: int = None, moveWindowBy: tuple[int, int] = (0, -1000), downloadDir: str | pathlib.Path = None, driverPath: str | pathlib.Path = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sits on top of selenium to streamline
automation and scraping tasks.</p>
<p>:param headless: If True, browser window will not be visible.</p>
<p>:param browserType: Which browser to use. Can be 'firefox' or 'chrome'.</p>
<p>:param implicitWait: Number of seconds to look for a specified element before
selenium considers it missing and throws an exception.</p>
<p>:param pageLoadTimeout: Time in seconds for selenium to wait for a page to load
before throwing an exception.</p>
<p>:param openBrowser: If True, opens a browser window when a User object is created.
If False, a manual call to self.openBrowser() must be made.</p>
<p>:param locatorMethod: The locator type User should expect to be given.
Can be 'xpath', 'id', 'className', 'name', or 'cssSelector'.
Every member function with a 'locator' argument refers to a string matching
the current locatorMethod.</p>
<p>:param randomizeUserAgent: If True, a random useragent will be used whenever
the browser is opened. If False, the native useragent will be used.</p>
<p>:param userAgentRotationPeriod: If not None, the browser window will be closed
and reopened with a new useragent every userAgentRotationPeriod number of minutes.
Rotation occurs on the first call to self.get() after the time period has elapsed.
Ignored if randomizeUserAgent is False.</p>
<p>:param moveWindowBy: The x and y amount of pixels to move the browser window by after opening.</p>
<p>:param downloadDir: The download folder to use. If None, the default folder will be used.</p>
<p>:param driverPath: The path to the webdriver executable selenium should use.
If None, the system PATH will be checked for the executable.
If the executable isn't found, the parent directories and the immediate child directories
of the current working directory will be searched.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User:
    &#34;&#34;&#34;Sits on top of selenium to streamline
    automation and scraping tasks.&#34;&#34;&#34;

    def __init__(
        self,
        headless: bool = False,
        browserType: str = &#34;firefox&#34;,
        implicitWait: int = 10,
        pageLoadTimeout: int = 60,
        openBrowser: bool = True,
        locatorMethod: str = &#34;xpath&#34;,
        randomizeUserAgent: bool = True,
        userAgentRotationPeriod: int = None,
        moveWindowBy: tuple[int, int] = (0, -1000),
        downloadDir: str | Path = None,
        driverPath: str | Path = None,
    ):
        &#34;&#34;&#34;
        :param headless: If True, browser window will not be visible.

        :param browserType: Which browser to use. Can be &#39;firefox&#39; or &#39;chrome&#39;.

        :param implicitWait: Number of seconds to look for a specified element before
        selenium considers it missing and throws an exception.

        :param pageLoadTimeout: Time in seconds for selenium to wait for a page to load
        before throwing an exception.

        :param openBrowser: If True, opens a browser window when a User object is created.
        If False, a manual call to self.openBrowser() must be made.

        :param locatorMethod: The locator type User should expect to be given.
        Can be &#39;xpath&#39;, &#39;id&#39;, &#39;className&#39;, &#39;name&#39;, or &#39;cssSelector&#39;.
        Every member function with a &#39;locator&#39; argument refers to a string matching
        the current locatorMethod.

        :param randomizeUserAgent: If True, a random useragent will be used whenever
        the browser is opened. If False, the native useragent will be used.

        :param userAgentRotationPeriod: If not None, the browser window will be closed
        and reopened with a new useragent every userAgentRotationPeriod number of minutes.
        Rotation occurs on the first call to self.get() after the time period has elapsed.
        Ignored if randomizeUserAgent is False.

        :param moveWindowBy: The x and y amount of pixels to move the browser window by after opening.

        :param downloadDir: The download folder to use. If None, the default folder will be used.

        :param driverPath: The path to the webdriver executable selenium should use.
        If None, the system PATH will be checked for the executable.
        If the executable isn&#39;t found, the parent directories and the immediate child directories
        of the current working directory will be searched.
        &#34;&#34;&#34;
        self.headless = headless
        browserType = browserType.lower()
        if browserType in [&#34;firefox&#34;, &#34;chrome&#34;]:
            self.browserType = browserType
        else:
            raise ValueError(&#34;&#39;browserType&#39; parameter must be &#39;firefox&#39; or &#39;chrome&#39;&#34;)
        self.browserOpen = False
        self.implicitWait = implicitWait
        self.pageLoadTimeout = pageLoadTimeout
        self.rotationTimer = Timer()
        self.timer = Timer()
        self.timer.start()
        self.randomizeUserAgent = randomizeUserAgent
        self.userAgentRotationPeriod = userAgentRotationPeriod
        self.locatorMethod = locatorMethod
        self.turbo()
        self.keys = Keys
        self.moveWindowBy = moveWindowBy
        self.downloadDir = downloadDir
        self.driverPath = driverPath
        if not self.driverPath:
            self.searchForDriver()
        if openBrowser:
            self.openBrowser()
        else:
            self.browser = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.closeBrowser()

    def configureFirefox(self) -&gt; FirefoxService:
        &#34;&#34;&#34;Configure options and profile for firefox.&#34;&#34;&#34;
        self.options = FirefoxOptions()
        self.options.headless = self.headless
        self.options.set_preference(
            &#34;widget.windows.window_occlusion_tracking.enabled&#34;, False
        )
        self.options.set_preference(&#34;dom.webaudio.enabled&#34;, False)
        if self.randomizeUserAgent:
            self.options.set_preference(&#34;general.useragent.override&#34;, getAgent())
        if self.downloadDir:
            Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
            self.profile = FirefoxProfile()
            self.profile.set_preference(&#34;browser.download.dir&#34;, str(self.downloadDir))
            self.profile.set_preference(&#34;browser.download.folderList&#34;, 2)
        else:
            self.profile = None
        self.service = FirefoxService(
            executable_path=str(self.driverPath), log_path=os.devnull
        )

    def configureChrome(self) -&gt; ChromeService:
        &#34;&#34;&#34;Configure options and profile for chrome.&#34;&#34;&#34;
        self.options = ChromeOptions()
        self.options.headless = self.headless
        self.options.add_argument(&#34;--disable-blink-features=AutomationControlled&#34;)
        self.options.add_argument(&#34;--mute-audio&#34;)
        self.options.add_argument(&#34;--disable-infobars&#34;)
        self.options.add_argument(&#34;--disable-notifications&#34;)
        self.options.add_argument(&#34;--log-level=3&#34;)
        if self.randomizeUserAgent:
            self.options.add_argument(f&#34;--user-agent={getAgent()}&#34;)
        self.options.add_experimental_option(&#34;useAutomationExtension&#34;, False)
        if self.downloadDir:
            Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
            self.options.add_experimental_option(
                &#34;prefs&#34;, {&#34;download.default_directory&#34;: str(self.downloadDir)}
            )
        self.service = ChromeService(
            executable_path=str(self.driverPath), log_path=os.devnull
        )

    def searchForDriver(self):
        &#34;&#34;&#34;Searches for the webdriver executable.&#34;&#34;&#34;
        cwd = Path.cwd()
        found = False
        match self.browserType:
            case &#34;firefox&#34;:
                driver = &#34;geckodriver.exe&#34;
            case &#34;chrome&#34;:
                driver = &#34;chromedriver.exe&#34;
        # search PATH
        envPath = os.environ[&#34;PATH&#34;]
        if sys.platform == &#34;win32&#34;:
            envPaths = envPath.split(&#34;;&#34;)
        else:
            envPaths = envPath.split(&#34;:&#34;)
            driver = driver[: driver.find(&#34;.&#34;)]
        for path in envPaths:
            if (Path(path) / driver).exists():
                self.driverPath = Path(path) / driver
                found = True
                break
        # check current working directory and parent folders
        if not found:
            while cwd != cwd.parent:
                if (cwd / driver).exists():
                    self.driverPath = cwd / driver
                    found = True
                    break
                cwd = cwd.parent
            # check top most level
            if not found and (cwd / driver).exists():
                self.driverPath = cwd / driver
                found = True
        # check child folders (only 1 level down)
        if not found:
            for child in Path.cwd().iterdir():
                if child.is_dir() and (child / driver).exists():
                    self.driverPath = child / driver
                    found = True
        if not found:
            warn(f&#34;Could not find {driver}&#34;)

    def setImplicitWait(self, waitTime: int = None):
        &#34;&#34;&#34;Sets to default time if no arg given.&#34;&#34;&#34;
        if not waitTime:
            self.browser.implicitly_wait(self.implicitWait)
        else:
            self.browser.implicitly_wait(waitTime)

    def openBrowser(self):
        &#34;&#34;&#34;Configures and opens selenium browser.&#34;&#34;&#34;
        if not self.browserOpen:
            match self.browserType:
                case &#34;firefox&#34;:
                    self.configureFirefox()
                    self.browser = webdriver.Firefox(
                        options=self.options,
                        service=self.service,
                        firefox_profile=self.profile,
                    )
                case &#34;chrome&#34;:
                    self.configureChrome()
                    self.browser = webdriver.Chrome(
                        options=self.options, service=self.service
                    )
            self.setImplicitWait()
            self.browser.maximize_window()
            self.browser.set_window_position(self.moveWindowBy[0], self.moveWindowBy[1])
            self.browser.maximize_window()
            self.browser.set_page_load_timeout(self.pageLoadTimeout)
            self.browserOpen = True
            self.tabIndex = 0
            self.rotationTimer.start()
        else:
            warn(&#34;Browser already open.&#34;)

    def closeBrowser(self):
        &#34;&#34;&#34;Close browser window.&#34;&#34;&#34;
        self.browserOpen = False
        self.browser.quit()

    def openTab(self, url: str = &#34;&#34;, switchToTab: bool = True):
        &#34;&#34;&#34;Opens new tab and, if provided, goes to url.

        New tab is inserted after currently active tab.&#34;&#34;&#34;
        self.script(&#34;window.open(arguments[0]);&#34;, url)
        if switchToTab:
            self.switchToTab(self.tabIndex + 1)

    def switchToTab(self, tabIndex: int):
        &#34;&#34;&#34;Switch to a tab in browser, zero indexed.&#34;&#34;&#34;
        self.browser.switch_to.window(self.browser.window_handles[tabIndex])
        self.tabIndex = tabIndex

    def getNumTabs(self) -&gt; int:
        &#34;&#34;&#34;Returns number of tabs open.&#34;&#34;&#34;
        return len(self.browser.window_handles)

    def closeTab(self, tabIndex: int = 1):
        &#34;&#34;&#34;Close specified tab and
        switches to tab index 0.&#34;&#34;&#34;
        self.switchToTab(tabIndex)
        self.browser.close()
        self.switchToTab(0)

    def get(self, url: str):
        &#34;&#34;&#34;Requests webpage at given url and rotates userAgent if necessary.&#34;&#34;&#34;
        if not self.browserOpen:
            self.openBrowser()
        if (
            self.randomizeUserAgent
            and self.userAgentRotationPeriod is not None
            and self.rotationTimer.check(format=False)
            &gt; (60 * self.userAgentRotationPeriod)
        ):
            self.rotationTimer.stop()
            self.closeBrowser()
            self.openBrowser()
        self.browser.get(url)
        self.script(&#34;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; false})&#34;)
        self.chill(self.arrivalWait)

    def getSoup(self) -&gt; BeautifulSoup:
        &#34;&#34;&#34;Returns a BeautifulSoup object
        of the current page source.&#34;&#34;&#34;
        return BeautifulSoup(self.browser.page_source, &#34;html.parser&#34;)

    def currentUrl(self) -&gt; str:
        &#34;&#34;&#34;Returns current url of active tab.&#34;&#34;&#34;
        return self.browser.current_url

    def deleteCookies(self):
        &#34;&#34;&#34;Delete all cookies for
        this browser instance.&#34;&#34;&#34;
        self.browser.delete_all_cookies()

    def turbo(self, engage: bool = True):
        &#34;&#34;&#34;When engaged, strings will be sent
        to elements all at once and there will be
        no waiting after actions.

        When disengaged, strings will be sent to elements
        &#39;one key at a time&#39; with randomized amounts of
        time between successive keys and after actions.&#34;&#34;&#34;
        if engage:
            self.afterKeyWait = (0, 0)
            self.afterFieldWait = (0, 0)
            self.afterClickWait = (0, 0)
            self.arrivalWait = (1, 1)
            self.oneKeyAtATime = False
            self.turboEngaged = True
        else:
            self.afterKeyWait = (0.1, 0.5)
            self.afterFieldWait = (1, 2)
            self.afterClickWait = (0.25, 1.5)
            self.arrivalWait = (4, 10)
            self.oneKeyAtATime = True
            self.turboEngaged = False

    def chill(self, minMax: tuple[float, float]):
        &#34;&#34;&#34;Sleeps a random amount
        between minMax[0] and minMax[1].&#34;&#34;&#34;
        time.sleep(random.uniform(minMax[0], minMax[1]))

    def script(self, script: str, args: Any = None) -&gt; Any:
        &#34;&#34;&#34;Execute javascript code and returns result.&#34;&#34;&#34;
        return self.browser.execute_script(script, args)

    def remove(self, locator: str):
        &#34;&#34;&#34;Removes element from DOM.&#34;&#34;&#34;
        self.script(&#34;arguments[0].remove();&#34;, self.find(locator))

    def getLength(self, locator: str) -&gt; int:
        &#34;&#34;&#34;Returns number of child elements for a given element.&#34;&#34;&#34;
        return int(self.script(&#34;return arguments[0].length;&#34;, self.find(locator)))

    def find(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Finds and returns a WebElement.&#34;&#34;&#34;
        match self.locatorMethod:
            case &#34;xpath&#34;:
                return self.browser.find_element(By.XPATH, locator)
            case &#34;id&#34;:
                return self.browser.find_element(By.ID, locator)
            case &#34;className&#34;:
                return self.browser.find_element(By.CLASS_NAME, locator)
            case &#34;name&#34;:
                return self.browser.find_element(By.NAME, locator)
            case &#34;cssSelector&#34;:
                return self.browser.find_element(By.CSS_SELECTOR, locator)

    def findChildren(self, locator: str) -&gt; list[WebElement]:
        &#34;&#34;&#34;Returns a list of child WebElements
        for given locator arg.&#34;&#34;&#34;
        element = self.find(locator)
        return element.find_elements(&#34;xpath&#34;, &#34;./*&#34;)

    def scroll(self, amount: int = None, fraction: float = None):
        &#34;&#34;&#34;Scroll web page.
        :param amount: The number of lines to scroll if not None.

        :param fraction: The amount between 0.0 and 1.0
        of the page height to scroll.

        If values are provided for both arguments,
        amount will be used.

        If values are provided for neither argument,
        the entire page length will be scrolled.

        Scrolls one line at a time if self.turbo is False.&#34;&#34;&#34;
        if amount:
            amountToScroll = amount
        elif fraction:
            amountToScroll = int(
                fraction
                * (
                    int(self.script(&#34;return document.body.scrollHeight;&#34;))
                    - int(self.script(&#34;return window.pageYOffset;&#34;))
                )
            )
        else:
            amountToScroll = int(self.script(&#34;return document.body.scrollHeight;&#34;))
        if self.turboEngaged:
            self.script(&#34;window.scrollBy(0,arguments[0]);&#34;, amountToScroll)
        else:
            for _ in range(abs(amountToScroll)):
                if amountToScroll &gt;= 0:
                    self.script(&#34;window.scrollBy(0,1);&#34;)
                else:
                    self.script(&#34;window.scrollBy(0,-1);&#34;)
        self.chill(self.afterClickWait)

    def scrollIntoView(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Scrolls to a given element and returns the element.&#34;&#34;&#34;
        element = self.find(locator)
        self.script(&#34;arguments[0].scrollIntoView();&#34;, element)
        self.chill(self.afterClickWait)
        return element

    def text(self, locator: str) -&gt; str:
        &#34;&#34;&#34;Returns text of WebElement.&#34;&#34;&#34;
        return self.find(locator).text

    def click(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Clicks on and returns WebElement.&#34;&#34;&#34;
        element = self.find(locator)
        element.click()
        self.chill(self.afterClickWait)
        return element

    def clear(self, locator: str) -&gt; WebElement:
        &#34;&#34;&#34;Clears content of WebElement if able
        and then returns WebElement.&#34;&#34;&#34;
        element = self.find(locator)
        element.clear()
        self.chill(self.afterClickWait)
        return element

    def switchToIframe(self, locator: str):
        &#34;&#34;&#34;Switch to an iframe from given locator.&#34;&#34;&#34;
        self.browser.switch_to.frame(self.find(locator))

    def switchToParentFrame(self):
        &#34;&#34;&#34;Move up a frame level from current frame.&#34;&#34;&#34;
        self.browser.switch_to.parent_frame()

    def select(
        self, locator: str, method: str, choice: str | int | tuple
    ) -&gt; WebElement:
        &#34;&#34;&#34;Select a choice from Select element.
        Returns the Select element from the locator string,
        not the option element that is selected.

        :param method: Can be &#39;value&#39; or &#39;index&#39;

        :param choice: The option to select.

        If method is &#39;value&#39;, then choice should be
        the html &#39;value&#39; attribute of the desired option.

        If method is &#39;index&#39;, choice can either be a single
        int for the desired option or it can be a two-tuple.
        If the tuple is provided, a random option between the
        two indicies (inclusive) will be selected.&#34;&#34;&#34;
        element = self.click(locator)
        match method:
            case &#34;value&#34;:
                Select(element).select_by_value(choice)
            case &#34;index&#34;:
                if type(choice) == tuple:
                    choice = random.randint(choice[0], choice[1])
                Select(element).select_by_index(choice)
        self.chill(self.afterFieldWait)
        return element

    def clickElements(
        self, locators: list[str], maxSelections: int = None, minSelections: int = 1
    ) -&gt; WebElement:
        &#34;&#34;&#34;Click a random number of WebElements
        and return the last WebElement clicked.

        :param locators: A list of element locators to choose from.

        :param maxSelections: The maximum number of elements to click.
        If None, the maximum will be the length of the locators list.

        :param minSelections: The minimum number of elements to click.

        e.g. self.clickElements([xpath1, xpath2, xpath3, xpath4], maxSelections=3)
        will click between 1 and 3 random elements from the list.
        &#34;&#34;&#34;
        if not maxSelections:
            maxSelections = len(locators)
        for option in random.sample(
            locators, k=random.randint(minSelections, maxSelections)
        ):
            element = self.click(option)
        return element

    def getClickList(
        self, numOptions: int, maxChoices: int = 1, minChoices: int = 1
    ) -&gt; list[str]:
        &#34;&#34;&#34;Similar to self.clickElements(), but for use with the self.fillNext() method.

        Creates a list of length &#39;numOptions&#39; where every element is &#39;skip&#39;.

        A random number of elements in the list between &#39;minChoices&#39; and &#39;maxChoices&#39; are
        replaced with &#39;keys.SPACE&#39; (interpreted as a click by almost all web forms).&#34;&#34;&#34;
        clickList = [&#34;skip&#34;] * numOptions
        selectedIndexes = []
        for i in range(random.randint(minChoices, maxChoices)):
            index = random.randint(0, numOptions - 1)
            while index in selectedIndexes:
                index = random.randint(0, numOptions - 1)
            selectedIndexes.append(index)
            clickList[index] = self.keys.SPACE
        return clickList

    def sendKeys(
        self, locator: str, data: str, clickFirst: bool = True, clearFirst: bool = False
    ) -&gt; WebElement:
        &#34;&#34;&#34;Types data into element and returns the element.

        :param data: The string to send to the element.

        :param clickFirst: If True, the element is clicked on
        before the data is sent.

        :param clearFirst: If True, the current text of the element
        is cleared before the data is sent.&#34;&#34;&#34;
        element = self.click(locator) if clickFirst else self.find(locator)
        if clearFirst:
            element.clear()
            self.chill(self.afterClickWait)
        if self.oneKeyAtATime:
            for ch in str(data):
                element.send_keys(ch)
                self.chill(self.afterKeyWait)
        else:
            element.send_keys(str(data))
        self.chill(self.afterFieldWait)
        return element

    def fillNext(
        self, data: list[str | tuple], startElement: WebElement = None
    ) -&gt; WebElement:
        &#34;&#34;&#34;Fills a form by tabbing from the current WebElement
        to the next one and using the corresponding item in data.
        Returns the last WebElement.

        :param data: A list of form data. If an item is a string (except for &#39;skip&#39;)
        it will be typed into the current WebElement.

        An item in data can be a two-tuple of the form
        (&#39;downArrow&#39;, numberOfPresses:int|tuple[int, int]).

        If numberOfPresses is a single int, Keys.ARROW_DOWN will be sent
        that many times to the WebElement.

        If numberOfPresses is a tuple, Keys.ARROW_DOWN will be sent a random
        number of times between numberOfPresses[0] and numberOfPresses[1] inclusive.
        This is typically for use with Select elements.

        An item in data can also be &#39;skip&#39;, which will perform no action on the current
        WebElement and will continue to the next one.

        :param startElement: The WebElement to start tabbing from.
        The currently active element will be used if startElement is None.

        Note: The function tabs to the next element before sending data,
        so the startElement should the WebElement before the one
        that should receive data[0].
        &#34;&#34;&#34;
        element = (
            self.browser.switch_to.active_element if not startElement else startElement
        )
        for datum in data:
            element.send_keys(Keys.TAB)
            element = self.browser.switch_to.active_element
            self.chill(self.afterKeyWait)
            if datum[0] == &#34;downArrow&#34;:
                if type(datum[1]) == tuple:
                    times = random.randint(datum[1][0], datum[1][1])
                else:
                    times = datum[1]
                for _ in range(times):
                    element.send_keys(Keys.ARROW_DOWN)
                    self.chill(self.afterKeyWait)
            elif datum == &#34;skip&#34;:
                self.chill(self.afterKeyWait)
            else:
                if self.turboEngaged:
                    element.send_keys(str(datum))
                else:
                    for ch in str(datum):
                        element.send_keys(ch)
                        self.chill(self.afterKeyWait)
            self.chill(self.afterFieldWait)
        return element

    def waitUntil(
        self, condition: LambdaType, maxWait: float = 10, pollingInterval: float = 0.1
    ):
        &#34;&#34;&#34;Checks condition repeatedly until either it is true,
        or the maxWait is exceeded.

        Raises a TimeoutError if the condition doesn&#39;t success within maxWait.

        Useful for determing whether a form has been successfully submitted.

        :param condition: The condition function to check.

        :param maxWait: Number of seconds to continue checking condition
        before throwing a TimeoutError.

        :param pollingInterval: The number of seconds to sleep before
        checking the condition function again after it fails.

        e.g. self.waitUntil(lambda: &#39;Successfully Submitted&#39; in self.text(&#39;//p[@id=&#34;form-output&#34;]))&#34;&#34;&#34;
        startTime = time.time()
        while True:
            try:
                if condition():
                    time.sleep(1)
                    break
                elif (time.time() - startTime) &gt; maxWait:
                    raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
                else:
                    time.sleep(pollingInterval)
            except:
                if (time.time() - startTime) &gt; maxWait:
                    raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
                else:
                    time.sleep(pollingInterval)

    def dismissAlert(self):
        &#34;&#34;&#34;Dismiss alert dialog.&#34;&#34;&#34;
        self.browser.switch_to.alert.dismiss()

    def solveRecaptchaV3(
        self,
        outerIframeXpath: str = &#39;//iframe[@title=&#34;reCAPTCHA&#34;]&#39;,
        innerIframeXpath: str = &#39;//iframe[@title=&#34;recaptcha challenge expires in two minutes&#34;]&#39;,
    ):
        &#34;&#34;&#34;Pass google recaptcha v3 by solving an audio puzzle.

        :param outerIframeXpath: Xpath to the iframe containing the recaptcha checkbox.
        If it&#39;s the recaptcha without the initial checkbox that just shows the image puzzle,
        pass None to this argument.

        &#34;&#34;&#34;
        locatorMethod = self.locatorMethod
        self.locatorMethod = &#34;xpath&#34;
        try:
            if outerIframeXpath:
                self.switchToIframe(outerIframeXpath)
                self.click(&#39;//*[@id=&#34;recaptcha-anchor&#34;]&#39;)
                self.switchToParentFrame()
            self.switchToIframe(innerIframeXpath)
            self.click(&#39;//*[@id=&#34;recaptcha-audio-button&#34;]&#39;)
            mp3Url = self.find(
                &#39;//a[@class=&#34;rc-audiochallenge-tdownload-link&#34;]&#39;
            ).get_attribute(&#34;href&#34;)
            text = getTextFromUrl(mp3Url, &#34;.mp3&#34;)
            self.sendKeys(&#39;//*[@id=&#34;audio-response&#34;]&#39;, text)
            self.click(&#39;//*[@id=&#34;recaptcha-verify-button&#34;]&#39;)
        except Exception as e:
            print(e)
            raise Exception(&#34;Could not solve captcha&#34;)
        finally:
            self.switchToParentFrame()
            self.locatorMethod = locatorMethod</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="seleniumUser.seleniumUser.User.chill"><code class="name flex">
<span>def <span class="ident">chill</span></span>(<span>self, minMax: tuple[float, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Sleeps a random amount
between minMax[0] and minMax[1].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chill(self, minMax: tuple[float, float]):
    &#34;&#34;&#34;Sleeps a random amount
    between minMax[0] and minMax[1].&#34;&#34;&#34;
    time.sleep(random.uniform(minMax[0], minMax[1]))</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, locator: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Clears content of WebElement if able
and then returns WebElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, locator: str) -&gt; WebElement:
    &#34;&#34;&#34;Clears content of WebElement if able
    and then returns WebElement.&#34;&#34;&#34;
    element = self.find(locator)
    element.clear()
    self.chill(self.afterClickWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self, locator: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Clicks on and returns WebElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(self, locator: str) -&gt; WebElement:
    &#34;&#34;&#34;Clicks on and returns WebElement.&#34;&#34;&#34;
    element = self.find(locator)
    element.click()
    self.chill(self.afterClickWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.clickElements"><code class="name flex">
<span>def <span class="ident">clickElements</span></span>(<span>self, locators: list[str], maxSelections: int = None, minSelections: int = 1) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Click a random number of WebElements
and return the last WebElement clicked.</p>
<p>:param locators: A list of element locators to choose from.</p>
<p>:param maxSelections: The maximum number of elements to click.
If None, the maximum will be the length of the locators list.</p>
<p>:param minSelections: The minimum number of elements to click.</p>
<p>e.g. self.clickElements([xpath1, xpath2, xpath3, xpath4], maxSelections=3)
will click between 1 and 3 random elements from the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clickElements(
    self, locators: list[str], maxSelections: int = None, minSelections: int = 1
) -&gt; WebElement:
    &#34;&#34;&#34;Click a random number of WebElements
    and return the last WebElement clicked.

    :param locators: A list of element locators to choose from.

    :param maxSelections: The maximum number of elements to click.
    If None, the maximum will be the length of the locators list.

    :param minSelections: The minimum number of elements to click.

    e.g. self.clickElements([xpath1, xpath2, xpath3, xpath4], maxSelections=3)
    will click between 1 and 3 random elements from the list.
    &#34;&#34;&#34;
    if not maxSelections:
        maxSelections = len(locators)
    for option in random.sample(
        locators, k=random.randint(minSelections, maxSelections)
    ):
        element = self.click(option)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.closeBrowser"><code class="name flex">
<span>def <span class="ident">closeBrowser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close browser window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeBrowser(self):
    &#34;&#34;&#34;Close browser window.&#34;&#34;&#34;
    self.browserOpen = False
    self.browser.quit()</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.closeTab"><code class="name flex">
<span>def <span class="ident">closeTab</span></span>(<span>self, tabIndex: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Close specified tab and
switches to tab index 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeTab(self, tabIndex: int = 1):
    &#34;&#34;&#34;Close specified tab and
    switches to tab index 0.&#34;&#34;&#34;
    self.switchToTab(tabIndex)
    self.browser.close()
    self.switchToTab(0)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.configureChrome"><code class="name flex">
<span>def <span class="ident">configureChrome</span></span>(<span>self) ‑> selenium.webdriver.chrome.service.Service</span>
</code></dt>
<dd>
<div class="desc"><p>Configure options and profile for chrome.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configureChrome(self) -&gt; ChromeService:
    &#34;&#34;&#34;Configure options and profile for chrome.&#34;&#34;&#34;
    self.options = ChromeOptions()
    self.options.headless = self.headless
    self.options.add_argument(&#34;--disable-blink-features=AutomationControlled&#34;)
    self.options.add_argument(&#34;--mute-audio&#34;)
    self.options.add_argument(&#34;--disable-infobars&#34;)
    self.options.add_argument(&#34;--disable-notifications&#34;)
    self.options.add_argument(&#34;--log-level=3&#34;)
    if self.randomizeUserAgent:
        self.options.add_argument(f&#34;--user-agent={getAgent()}&#34;)
    self.options.add_experimental_option(&#34;useAutomationExtension&#34;, False)
    if self.downloadDir:
        Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
        self.options.add_experimental_option(
            &#34;prefs&#34;, {&#34;download.default_directory&#34;: str(self.downloadDir)}
        )
    self.service = ChromeService(
        executable_path=str(self.driverPath), log_path=os.devnull
    )</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.configureFirefox"><code class="name flex">
<span>def <span class="ident">configureFirefox</span></span>(<span>self) ‑> selenium.webdriver.firefox.service.Service</span>
</code></dt>
<dd>
<div class="desc"><p>Configure options and profile for firefox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configureFirefox(self) -&gt; FirefoxService:
    &#34;&#34;&#34;Configure options and profile for firefox.&#34;&#34;&#34;
    self.options = FirefoxOptions()
    self.options.headless = self.headless
    self.options.set_preference(
        &#34;widget.windows.window_occlusion_tracking.enabled&#34;, False
    )
    self.options.set_preference(&#34;dom.webaudio.enabled&#34;, False)
    if self.randomizeUserAgent:
        self.options.set_preference(&#34;general.useragent.override&#34;, getAgent())
    if self.downloadDir:
        Path(self.downloadDir).mkdir(parents=True, exist_ok=True)
        self.profile = FirefoxProfile()
        self.profile.set_preference(&#34;browser.download.dir&#34;, str(self.downloadDir))
        self.profile.set_preference(&#34;browser.download.folderList&#34;, 2)
    else:
        self.profile = None
    self.service = FirefoxService(
        executable_path=str(self.driverPath), log_path=os.devnull
    )</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.currentUrl"><code class="name flex">
<span>def <span class="ident">currentUrl</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns current url of active tab.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def currentUrl(self) -&gt; str:
    &#34;&#34;&#34;Returns current url of active tab.&#34;&#34;&#34;
    return self.browser.current_url</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.deleteCookies"><code class="name flex">
<span>def <span class="ident">deleteCookies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all cookies for
this browser instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteCookies(self):
    &#34;&#34;&#34;Delete all cookies for
    this browser instance.&#34;&#34;&#34;
    self.browser.delete_all_cookies()</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.dismissAlert"><code class="name flex">
<span>def <span class="ident">dismissAlert</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Dismiss alert dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dismissAlert(self):
    &#34;&#34;&#34;Dismiss alert dialog.&#34;&#34;&#34;
    self.browser.switch_to.alert.dismiss()</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.fillNext"><code class="name flex">
<span>def <span class="ident">fillNext</span></span>(<span>self, data: list[str | tuple], startElement: selenium.webdriver.remote.webelement.WebElement = None) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Fills a form by tabbing from the current WebElement
to the next one and using the corresponding item in data.
Returns the last WebElement.</p>
<p>:param data: A list of form data. If an item is a string (except for 'skip')
it will be typed into the current WebElement.</p>
<p>An item in data can be a two-tuple of the form
('downArrow', numberOfPresses:int|tuple[int, int]).</p>
<p>If numberOfPresses is a single int, Keys.ARROW_DOWN will be sent
that many times to the WebElement.</p>
<p>If numberOfPresses is a tuple, Keys.ARROW_DOWN will be sent a random
number of times between numberOfPresses[0] and numberOfPresses[1] inclusive.
This is typically for use with Select elements.</p>
<p>An item in data can also be 'skip', which will perform no action on the current
WebElement and will continue to the next one.</p>
<p>:param startElement: The WebElement to start tabbing from.
The currently active element will be used if startElement is None.</p>
<p>Note: The function tabs to the next element before sending data,
so the startElement should the WebElement before the one
that should receive data[0].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fillNext(
    self, data: list[str | tuple], startElement: WebElement = None
) -&gt; WebElement:
    &#34;&#34;&#34;Fills a form by tabbing from the current WebElement
    to the next one and using the corresponding item in data.
    Returns the last WebElement.

    :param data: A list of form data. If an item is a string (except for &#39;skip&#39;)
    it will be typed into the current WebElement.

    An item in data can be a two-tuple of the form
    (&#39;downArrow&#39;, numberOfPresses:int|tuple[int, int]).

    If numberOfPresses is a single int, Keys.ARROW_DOWN will be sent
    that many times to the WebElement.

    If numberOfPresses is a tuple, Keys.ARROW_DOWN will be sent a random
    number of times between numberOfPresses[0] and numberOfPresses[1] inclusive.
    This is typically for use with Select elements.

    An item in data can also be &#39;skip&#39;, which will perform no action on the current
    WebElement and will continue to the next one.

    :param startElement: The WebElement to start tabbing from.
    The currently active element will be used if startElement is None.

    Note: The function tabs to the next element before sending data,
    so the startElement should the WebElement before the one
    that should receive data[0].
    &#34;&#34;&#34;
    element = (
        self.browser.switch_to.active_element if not startElement else startElement
    )
    for datum in data:
        element.send_keys(Keys.TAB)
        element = self.browser.switch_to.active_element
        self.chill(self.afterKeyWait)
        if datum[0] == &#34;downArrow&#34;:
            if type(datum[1]) == tuple:
                times = random.randint(datum[1][0], datum[1][1])
            else:
                times = datum[1]
            for _ in range(times):
                element.send_keys(Keys.ARROW_DOWN)
                self.chill(self.afterKeyWait)
        elif datum == &#34;skip&#34;:
            self.chill(self.afterKeyWait)
        else:
            if self.turboEngaged:
                element.send_keys(str(datum))
            else:
                for ch in str(datum):
                    element.send_keys(ch)
                    self.chill(self.afterKeyWait)
        self.chill(self.afterFieldWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, locator: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and returns a WebElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, locator: str) -&gt; WebElement:
    &#34;&#34;&#34;Finds and returns a WebElement.&#34;&#34;&#34;
    match self.locatorMethod:
        case &#34;xpath&#34;:
            return self.browser.find_element(By.XPATH, locator)
        case &#34;id&#34;:
            return self.browser.find_element(By.ID, locator)
        case &#34;className&#34;:
            return self.browser.find_element(By.CLASS_NAME, locator)
        case &#34;name&#34;:
            return self.browser.find_element(By.NAME, locator)
        case &#34;cssSelector&#34;:
            return self.browser.find_element(By.CSS_SELECTOR, locator)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.findChildren"><code class="name flex">
<span>def <span class="ident">findChildren</span></span>(<span>self, locator: str) ‑> list[selenium.webdriver.remote.webelement.WebElement]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of child WebElements
for given locator arg.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findChildren(self, locator: str) -&gt; list[WebElement]:
    &#34;&#34;&#34;Returns a list of child WebElements
    for given locator arg.&#34;&#34;&#34;
    element = self.find(locator)
    return element.find_elements(&#34;xpath&#34;, &#34;./*&#34;)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, url: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Requests webpage at given url and rotates userAgent if necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, url: str):
    &#34;&#34;&#34;Requests webpage at given url and rotates userAgent if necessary.&#34;&#34;&#34;
    if not self.browserOpen:
        self.openBrowser()
    if (
        self.randomizeUserAgent
        and self.userAgentRotationPeriod is not None
        and self.rotationTimer.check(format=False)
        &gt; (60 * self.userAgentRotationPeriod)
    ):
        self.rotationTimer.stop()
        self.closeBrowser()
        self.openBrowser()
    self.browser.get(url)
    self.script(&#34;Object.defineProperty(navigator, &#39;webdriver&#39;, {get: () =&gt; false})&#34;)
    self.chill(self.arrivalWait)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.getClickList"><code class="name flex">
<span>def <span class="ident">getClickList</span></span>(<span>self, numOptions: int, maxChoices: int = 1, minChoices: int = 1) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to self.clickElements(), but for use with the self.fillNext() method.</p>
<p>Creates a list of length 'numOptions' where every element is 'skip'.</p>
<p>A random number of elements in the list between 'minChoices' and 'maxChoices' are
replaced with 'keys.SPACE' (interpreted as a click by almost all web forms).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getClickList(
    self, numOptions: int, maxChoices: int = 1, minChoices: int = 1
) -&gt; list[str]:
    &#34;&#34;&#34;Similar to self.clickElements(), but for use with the self.fillNext() method.

    Creates a list of length &#39;numOptions&#39; where every element is &#39;skip&#39;.

    A random number of elements in the list between &#39;minChoices&#39; and &#39;maxChoices&#39; are
    replaced with &#39;keys.SPACE&#39; (interpreted as a click by almost all web forms).&#34;&#34;&#34;
    clickList = [&#34;skip&#34;] * numOptions
    selectedIndexes = []
    for i in range(random.randint(minChoices, maxChoices)):
        index = random.randint(0, numOptions - 1)
        while index in selectedIndexes:
            index = random.randint(0, numOptions - 1)
        selectedIndexes.append(index)
        clickList[index] = self.keys.SPACE
    return clickList</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.getLength"><code class="name flex">
<span>def <span class="ident">getLength</span></span>(<span>self, locator: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns number of child elements for a given element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLength(self, locator: str) -&gt; int:
    &#34;&#34;&#34;Returns number of child elements for a given element.&#34;&#34;&#34;
    return int(self.script(&#34;return arguments[0].length;&#34;, self.find(locator)))</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.getNumTabs"><code class="name flex">
<span>def <span class="ident">getNumTabs</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns number of tabs open.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNumTabs(self) -&gt; int:
    &#34;&#34;&#34;Returns number of tabs open.&#34;&#34;&#34;
    return len(self.browser.window_handles)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.getSoup"><code class="name flex">
<span>def <span class="ident">getSoup</span></span>(<span>self) ‑> bs4.BeautifulSoup</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a BeautifulSoup object
of the current page source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSoup(self) -&gt; BeautifulSoup:
    &#34;&#34;&#34;Returns a BeautifulSoup object
    of the current page source.&#34;&#34;&#34;
    return BeautifulSoup(self.browser.page_source, &#34;html.parser&#34;)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.openBrowser"><code class="name flex">
<span>def <span class="ident">openBrowser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures and opens selenium browser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openBrowser(self):
    &#34;&#34;&#34;Configures and opens selenium browser.&#34;&#34;&#34;
    if not self.browserOpen:
        match self.browserType:
            case &#34;firefox&#34;:
                self.configureFirefox()
                self.browser = webdriver.Firefox(
                    options=self.options,
                    service=self.service,
                    firefox_profile=self.profile,
                )
            case &#34;chrome&#34;:
                self.configureChrome()
                self.browser = webdriver.Chrome(
                    options=self.options, service=self.service
                )
        self.setImplicitWait()
        self.browser.maximize_window()
        self.browser.set_window_position(self.moveWindowBy[0], self.moveWindowBy[1])
        self.browser.maximize_window()
        self.browser.set_page_load_timeout(self.pageLoadTimeout)
        self.browserOpen = True
        self.tabIndex = 0
        self.rotationTimer.start()
    else:
        warn(&#34;Browser already open.&#34;)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.openTab"><code class="name flex">
<span>def <span class="ident">openTab</span></span>(<span>self, url: str = '', switchToTab: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens new tab and, if provided, goes to url.</p>
<p>New tab is inserted after currently active tab.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openTab(self, url: str = &#34;&#34;, switchToTab: bool = True):
    &#34;&#34;&#34;Opens new tab and, if provided, goes to url.

    New tab is inserted after currently active tab.&#34;&#34;&#34;
    self.script(&#34;window.open(arguments[0]);&#34;, url)
    if switchToTab:
        self.switchToTab(self.tabIndex + 1)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, locator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes element from DOM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, locator: str):
    &#34;&#34;&#34;Removes element from DOM.&#34;&#34;&#34;
    self.script(&#34;arguments[0].remove();&#34;, self.find(locator))</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, script: str, args: Any = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Execute javascript code and returns result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self, script: str, args: Any = None) -&gt; Any:
    &#34;&#34;&#34;Execute javascript code and returns result.&#34;&#34;&#34;
    return self.browser.execute_script(script, args)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.scroll"><code class="name flex">
<span>def <span class="ident">scroll</span></span>(<span>self, amount: int = None, fraction: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll web page.
:param amount: The number of lines to scroll if not None.</p>
<p>:param fraction: The amount between 0.0 and 1.0
of the page height to scroll.</p>
<p>If values are provided for both arguments,
amount will be used.</p>
<p>If values are provided for neither argument,
the entire page length will be scrolled.</p>
<p>Scrolls one line at a time if self.turbo is False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll(self, amount: int = None, fraction: float = None):
    &#34;&#34;&#34;Scroll web page.
    :param amount: The number of lines to scroll if not None.

    :param fraction: The amount between 0.0 and 1.0
    of the page height to scroll.

    If values are provided for both arguments,
    amount will be used.

    If values are provided for neither argument,
    the entire page length will be scrolled.

    Scrolls one line at a time if self.turbo is False.&#34;&#34;&#34;
    if amount:
        amountToScroll = amount
    elif fraction:
        amountToScroll = int(
            fraction
            * (
                int(self.script(&#34;return document.body.scrollHeight;&#34;))
                - int(self.script(&#34;return window.pageYOffset;&#34;))
            )
        )
    else:
        amountToScroll = int(self.script(&#34;return document.body.scrollHeight;&#34;))
    if self.turboEngaged:
        self.script(&#34;window.scrollBy(0,arguments[0]);&#34;, amountToScroll)
    else:
        for _ in range(abs(amountToScroll)):
            if amountToScroll &gt;= 0:
                self.script(&#34;window.scrollBy(0,1);&#34;)
            else:
                self.script(&#34;window.scrollBy(0,-1);&#34;)
    self.chill(self.afterClickWait)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.scrollIntoView"><code class="name flex">
<span>def <span class="ident">scrollIntoView</span></span>(<span>self, locator: str) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Scrolls to a given element and returns the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollIntoView(self, locator: str) -&gt; WebElement:
    &#34;&#34;&#34;Scrolls to a given element and returns the element.&#34;&#34;&#34;
    element = self.find(locator)
    self.script(&#34;arguments[0].scrollIntoView();&#34;, element)
    self.chill(self.afterClickWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.searchForDriver"><code class="name flex">
<span>def <span class="ident">searchForDriver</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for the webdriver executable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def searchForDriver(self):
    &#34;&#34;&#34;Searches for the webdriver executable.&#34;&#34;&#34;
    cwd = Path.cwd()
    found = False
    match self.browserType:
        case &#34;firefox&#34;:
            driver = &#34;geckodriver.exe&#34;
        case &#34;chrome&#34;:
            driver = &#34;chromedriver.exe&#34;
    # search PATH
    envPath = os.environ[&#34;PATH&#34;]
    if sys.platform == &#34;win32&#34;:
        envPaths = envPath.split(&#34;;&#34;)
    else:
        envPaths = envPath.split(&#34;:&#34;)
        driver = driver[: driver.find(&#34;.&#34;)]
    for path in envPaths:
        if (Path(path) / driver).exists():
            self.driverPath = Path(path) / driver
            found = True
            break
    # check current working directory and parent folders
    if not found:
        while cwd != cwd.parent:
            if (cwd / driver).exists():
                self.driverPath = cwd / driver
                found = True
                break
            cwd = cwd.parent
        # check top most level
        if not found and (cwd / driver).exists():
            self.driverPath = cwd / driver
            found = True
    # check child folders (only 1 level down)
    if not found:
        for child in Path.cwd().iterdir():
            if child.is_dir() and (child / driver).exists():
                self.driverPath = child / driver
                found = True
    if not found:
        warn(f&#34;Could not find {driver}&#34;)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, locator: str, method: str, choice: str | int | tuple) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Select a choice from Select element.
Returns the Select element from the locator string,
not the option element that is selected.</p>
<p>:param method: Can be 'value' or 'index'</p>
<p>:param choice: The option to select.</p>
<p>If method is 'value', then choice should be
the html 'value' attribute of the desired option.</p>
<p>If method is 'index', choice can either be a single
int for the desired option or it can be a two-tuple.
If the tuple is provided, a random option between the
two indicies (inclusive) will be selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(
    self, locator: str, method: str, choice: str | int | tuple
) -&gt; WebElement:
    &#34;&#34;&#34;Select a choice from Select element.
    Returns the Select element from the locator string,
    not the option element that is selected.

    :param method: Can be &#39;value&#39; or &#39;index&#39;

    :param choice: The option to select.

    If method is &#39;value&#39;, then choice should be
    the html &#39;value&#39; attribute of the desired option.

    If method is &#39;index&#39;, choice can either be a single
    int for the desired option or it can be a two-tuple.
    If the tuple is provided, a random option between the
    two indicies (inclusive) will be selected.&#34;&#34;&#34;
    element = self.click(locator)
    match method:
        case &#34;value&#34;:
            Select(element).select_by_value(choice)
        case &#34;index&#34;:
            if type(choice) == tuple:
                choice = random.randint(choice[0], choice[1])
            Select(element).select_by_index(choice)
    self.chill(self.afterFieldWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.sendKeys"><code class="name flex">
<span>def <span class="ident">sendKeys</span></span>(<span>self, locator: str, data: str, clickFirst: bool = True, clearFirst: bool = False) ‑> selenium.webdriver.remote.webelement.WebElement</span>
</code></dt>
<dd>
<div class="desc"><p>Types data into element and returns the element.</p>
<p>:param data: The string to send to the element.</p>
<p>:param clickFirst: If True, the element is clicked on
before the data is sent.</p>
<p>:param clearFirst: If True, the current text of the element
is cleared before the data is sent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendKeys(
    self, locator: str, data: str, clickFirst: bool = True, clearFirst: bool = False
) -&gt; WebElement:
    &#34;&#34;&#34;Types data into element and returns the element.

    :param data: The string to send to the element.

    :param clickFirst: If True, the element is clicked on
    before the data is sent.

    :param clearFirst: If True, the current text of the element
    is cleared before the data is sent.&#34;&#34;&#34;
    element = self.click(locator) if clickFirst else self.find(locator)
    if clearFirst:
        element.clear()
        self.chill(self.afterClickWait)
    if self.oneKeyAtATime:
        for ch in str(data):
            element.send_keys(ch)
            self.chill(self.afterKeyWait)
    else:
        element.send_keys(str(data))
    self.chill(self.afterFieldWait)
    return element</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.setImplicitWait"><code class="name flex">
<span>def <span class="ident">setImplicitWait</span></span>(<span>self, waitTime: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets to default time if no arg given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setImplicitWait(self, waitTime: int = None):
    &#34;&#34;&#34;Sets to default time if no arg given.&#34;&#34;&#34;
    if not waitTime:
        self.browser.implicitly_wait(self.implicitWait)
    else:
        self.browser.implicitly_wait(waitTime)</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.solveRecaptchaV3"><code class="name flex">
<span>def <span class="ident">solveRecaptchaV3</span></span>(<span>self, outerIframeXpath: str = '//iframe[@title="reCAPTCHA"]', innerIframeXpath: str = '//iframe[@title="recaptcha challenge expires in two minutes"]')</span>
</code></dt>
<dd>
<div class="desc"><p>Pass google recaptcha v3 by solving an audio puzzle.</p>
<p>:param outerIframeXpath: Xpath to the iframe containing the recaptcha checkbox.
If it's the recaptcha without the initial checkbox that just shows the image puzzle,
pass None to this argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solveRecaptchaV3(
    self,
    outerIframeXpath: str = &#39;//iframe[@title=&#34;reCAPTCHA&#34;]&#39;,
    innerIframeXpath: str = &#39;//iframe[@title=&#34;recaptcha challenge expires in two minutes&#34;]&#39;,
):
    &#34;&#34;&#34;Pass google recaptcha v3 by solving an audio puzzle.

    :param outerIframeXpath: Xpath to the iframe containing the recaptcha checkbox.
    If it&#39;s the recaptcha without the initial checkbox that just shows the image puzzle,
    pass None to this argument.

    &#34;&#34;&#34;
    locatorMethod = self.locatorMethod
    self.locatorMethod = &#34;xpath&#34;
    try:
        if outerIframeXpath:
            self.switchToIframe(outerIframeXpath)
            self.click(&#39;//*[@id=&#34;recaptcha-anchor&#34;]&#39;)
            self.switchToParentFrame()
        self.switchToIframe(innerIframeXpath)
        self.click(&#39;//*[@id=&#34;recaptcha-audio-button&#34;]&#39;)
        mp3Url = self.find(
            &#39;//a[@class=&#34;rc-audiochallenge-tdownload-link&#34;]&#39;
        ).get_attribute(&#34;href&#34;)
        text = getTextFromUrl(mp3Url, &#34;.mp3&#34;)
        self.sendKeys(&#39;//*[@id=&#34;audio-response&#34;]&#39;, text)
        self.click(&#39;//*[@id=&#34;recaptcha-verify-button&#34;]&#39;)
    except Exception as e:
        print(e)
        raise Exception(&#34;Could not solve captcha&#34;)
    finally:
        self.switchToParentFrame()
        self.locatorMethod = locatorMethod</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.switchToIframe"><code class="name flex">
<span>def <span class="ident">switchToIframe</span></span>(<span>self, locator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch to an iframe from given locator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchToIframe(self, locator: str):
    &#34;&#34;&#34;Switch to an iframe from given locator.&#34;&#34;&#34;
    self.browser.switch_to.frame(self.find(locator))</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.switchToParentFrame"><code class="name flex">
<span>def <span class="ident">switchToParentFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move up a frame level from current frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchToParentFrame(self):
    &#34;&#34;&#34;Move up a frame level from current frame.&#34;&#34;&#34;
    self.browser.switch_to.parent_frame()</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.switchToTab"><code class="name flex">
<span>def <span class="ident">switchToTab</span></span>(<span>self, tabIndex: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch to a tab in browser, zero indexed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchToTab(self, tabIndex: int):
    &#34;&#34;&#34;Switch to a tab in browser, zero indexed.&#34;&#34;&#34;
    self.browser.switch_to.window(self.browser.window_handles[tabIndex])
    self.tabIndex = tabIndex</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, locator: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns text of WebElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(self, locator: str) -&gt; str:
    &#34;&#34;&#34;Returns text of WebElement.&#34;&#34;&#34;
    return self.find(locator).text</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.turbo"><code class="name flex">
<span>def <span class="ident">turbo</span></span>(<span>self, engage: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>When engaged, strings will be sent
to elements all at once and there will be
no waiting after actions.</p>
<p>When disengaged, strings will be sent to elements
'one key at a time' with randomized amounts of
time between successive keys and after actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turbo(self, engage: bool = True):
    &#34;&#34;&#34;When engaged, strings will be sent
    to elements all at once and there will be
    no waiting after actions.

    When disengaged, strings will be sent to elements
    &#39;one key at a time&#39; with randomized amounts of
    time between successive keys and after actions.&#34;&#34;&#34;
    if engage:
        self.afterKeyWait = (0, 0)
        self.afterFieldWait = (0, 0)
        self.afterClickWait = (0, 0)
        self.arrivalWait = (1, 1)
        self.oneKeyAtATime = False
        self.turboEngaged = True
    else:
        self.afterKeyWait = (0.1, 0.5)
        self.afterFieldWait = (1, 2)
        self.afterClickWait = (0.25, 1.5)
        self.arrivalWait = (4, 10)
        self.oneKeyAtATime = True
        self.turboEngaged = False</code></pre>
</details>
</dd>
<dt id="seleniumUser.seleniumUser.User.waitUntil"><code class="name flex">
<span>def <span class="ident">waitUntil</span></span>(<span>self, condition: function, maxWait: float = 10, pollingInterval: float = 0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks condition repeatedly until either it is true,
or the maxWait is exceeded.</p>
<p>Raises a TimeoutError if the condition doesn't success within maxWait.</p>
<p>Useful for determing whether a form has been successfully submitted.</p>
<p>:param condition: The condition function to check.</p>
<p>:param maxWait: Number of seconds to continue checking condition
before throwing a TimeoutError.</p>
<p>:param pollingInterval: The number of seconds to sleep before
checking the condition function again after it fails.</p>
<p>e.g. self.waitUntil(lambda: 'Successfully Submitted' in self.text('//p[@id="form-output"]))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitUntil(
    self, condition: LambdaType, maxWait: float = 10, pollingInterval: float = 0.1
):
    &#34;&#34;&#34;Checks condition repeatedly until either it is true,
    or the maxWait is exceeded.

    Raises a TimeoutError if the condition doesn&#39;t success within maxWait.

    Useful for determing whether a form has been successfully submitted.

    :param condition: The condition function to check.

    :param maxWait: Number of seconds to continue checking condition
    before throwing a TimeoutError.

    :param pollingInterval: The number of seconds to sleep before
    checking the condition function again after it fails.

    e.g. self.waitUntil(lambda: &#39;Successfully Submitted&#39; in self.text(&#39;//p[@id=&#34;form-output&#34;]))&#34;&#34;&#34;
    startTime = time.time()
    while True:
        try:
            if condition():
                time.sleep(1)
                break
            elif (time.time() - startTime) &gt; maxWait:
                raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
            else:
                time.sleep(pollingInterval)
        except:
            if (time.time() - startTime) &gt; maxWait:
                raise TimeoutError(f&#34;maxWait exceeded in waitUntil({condition})&#34;)
            else:
                time.sleep(pollingInterval)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seleniumUser" href="index.html">seleniumUser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="seleniumUser.seleniumUser.User" href="#seleniumUser.seleniumUser.User">User</a></code></h4>
<ul class="two-column">
<li><code><a title="seleniumUser.seleniumUser.User.chill" href="#seleniumUser.seleniumUser.User.chill">chill</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.clear" href="#seleniumUser.seleniumUser.User.clear">clear</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.click" href="#seleniumUser.seleniumUser.User.click">click</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.clickElements" href="#seleniumUser.seleniumUser.User.clickElements">clickElements</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.closeBrowser" href="#seleniumUser.seleniumUser.User.closeBrowser">closeBrowser</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.closeTab" href="#seleniumUser.seleniumUser.User.closeTab">closeTab</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.configureChrome" href="#seleniumUser.seleniumUser.User.configureChrome">configureChrome</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.configureFirefox" href="#seleniumUser.seleniumUser.User.configureFirefox">configureFirefox</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.currentUrl" href="#seleniumUser.seleniumUser.User.currentUrl">currentUrl</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.deleteCookies" href="#seleniumUser.seleniumUser.User.deleteCookies">deleteCookies</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.dismissAlert" href="#seleniumUser.seleniumUser.User.dismissAlert">dismissAlert</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.fillNext" href="#seleniumUser.seleniumUser.User.fillNext">fillNext</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.find" href="#seleniumUser.seleniumUser.User.find">find</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.findChildren" href="#seleniumUser.seleniumUser.User.findChildren">findChildren</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.get" href="#seleniumUser.seleniumUser.User.get">get</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.getClickList" href="#seleniumUser.seleniumUser.User.getClickList">getClickList</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.getLength" href="#seleniumUser.seleniumUser.User.getLength">getLength</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.getNumTabs" href="#seleniumUser.seleniumUser.User.getNumTabs">getNumTabs</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.getSoup" href="#seleniumUser.seleniumUser.User.getSoup">getSoup</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.openBrowser" href="#seleniumUser.seleniumUser.User.openBrowser">openBrowser</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.openTab" href="#seleniumUser.seleniumUser.User.openTab">openTab</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.remove" href="#seleniumUser.seleniumUser.User.remove">remove</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.script" href="#seleniumUser.seleniumUser.User.script">script</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.scroll" href="#seleniumUser.seleniumUser.User.scroll">scroll</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.scrollIntoView" href="#seleniumUser.seleniumUser.User.scrollIntoView">scrollIntoView</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.searchForDriver" href="#seleniumUser.seleniumUser.User.searchForDriver">searchForDriver</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.select" href="#seleniumUser.seleniumUser.User.select">select</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.sendKeys" href="#seleniumUser.seleniumUser.User.sendKeys">sendKeys</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.setImplicitWait" href="#seleniumUser.seleniumUser.User.setImplicitWait">setImplicitWait</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.solveRecaptchaV3" href="#seleniumUser.seleniumUser.User.solveRecaptchaV3">solveRecaptchaV3</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.switchToIframe" href="#seleniumUser.seleniumUser.User.switchToIframe">switchToIframe</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.switchToParentFrame" href="#seleniumUser.seleniumUser.User.switchToParentFrame">switchToParentFrame</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.switchToTab" href="#seleniumUser.seleniumUser.User.switchToTab">switchToTab</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.text" href="#seleniumUser.seleniumUser.User.text">text</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.turbo" href="#seleniumUser.seleniumUser.User.turbo">turbo</a></code></li>
<li><code><a title="seleniumUser.seleniumUser.User.waitUntil" href="#seleniumUser.seleniumUser.User.waitUntil">waitUntil</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>