from logging import Logger

import six
from saml2.assertion import Assertion

from saml2.saml import AttributeStatement, SubjectConfirmation

from saml2 import (
    SAMLError as SAMLError,
    extension_elements_to_elements as extension_elements_to_elements,
    saml as saml,
    samlp as samlp,
    time_util as time_util,
    SamlBase,
)
from saml2.attribute_converter import to_local as to_local
from saml2.sigver import (
    DecryptError as DecryptError,
    SignatureError as SignatureError,
    security_context as security_context,
    signed as signed,
)
from typing import Any, Optional, Union

logger: Logger

class IncorrectlySigned(SAMLError): ...
class InvalidAssertion(SAMLError): ...
class DecryptionFailed(SAMLError): ...
class VerificationError(SAMLError): ...
class StatusError(SAMLError): ...
class UnsolicitedResponse(SAMLError): ...
class StatusVersionMismatch(StatusError): ...
class StatusAuthnFailed(StatusError): ...
class StatusInvalidAttrNameOrValue(StatusError): ...
class StatusInvalidAuthnResponseStatement(StatusError): ...
class StatusInvalidNameidPolicy(StatusError): ...
class StatusNoAuthnContext(StatusError): ...
class StatusNoAvailableIdp(StatusError): ...
class StatusNoPassive(StatusError): ...
class StatusNoSupportedIdp(StatusError): ...
class StatusPartialLogout(StatusError): ...
class StatusProxyCountExceeded(StatusError): ...
class StatusRequestDenied(StatusError): ...
class StatusRequestUnsupported(StatusError): ...
class StatusRequestVersionDeprecated(StatusError): ...
class StatusRequestVersionTooHigh(StatusError): ...
class StatusRequestVersionTooLow(StatusError): ...
class StatusResourceNotRecognized(StatusError): ...
class StatusTooManyResponses(StatusError): ...
class StatusUnknownAttrProfile(StatusError): ...
class StatusUnknownPrincipal(StatusError): ...
class StatusUnsupportedBinding(StatusError): ...
class StatusResponder(StatusError): ...

STATUSCODE2EXCEPTION: Any

class StatusResponse:
    msgtype: str
    sec: Any
    return_addrs: list[Any]
    timeslack: int
    request_id: int
    xmlstr: str
    origxml: str
    name_id: Optional[str]
    response: StatusResponse
    not_on_or_after: int
    in_response_to: Optional[Any]
    signature_check: Any
    require_signature: bool
    require_response_signature: bool
    require_signature_or_response_signature: bool
    not_signed: bool
    asynchop: bool
    do_not_verify: bool
    conv_info: dict[str, Any]

    def __init__(
        self,
        sec_context: Any,
        return_addrs: Optional[Any] = ...,
        timeslack: int = ...,
        request_id: int = ...,
        asynchop: bool = ...,
        conv_info: Optional[dict[str, Any]] = ...,
    ) -> None: ...
    def load_instance(self, instance: SamlBase) -> StatusResponse: ...
    def status_ok(self) -> bool: ...
    def issue_instant_ok(self) -> bool: ...
    def loads(
        self, xmldata: Union[str, six.binary_type], decode: bool = ..., origxml: Optional[str] = ...
    ) -> StatusResponse: ...
    def verify(self, keys: Optional[Any] = ...) -> Union[StatusResponse, bool, None]: ...
    def update(self, mold: Any) -> None: ...
    def issuer(self) -> str: ...

class AuthnResponse(StatusResponse):
    msgtype: str
    entity_id: Any
    attribute_converters: Any
    outstanding_queries: dict[str, Any]
    context: str
    came_from: Optional[Any]
    ava: Optional[Any]
    assertion: Optional[Any]
    assertions: list[Any]
    session_not_on_or_after: int
    allow_unsolicited: bool
    require_signature: bool
    require_signature_or_response_signature: bool
    require_response_signature: bool
    test: bool
    allow_unknown_attributes: bool
    extension_schema: dict[str, Any]
    response: AuthnResponse

    def __init__(
        self,
        sec_context: Any,
        attribute_converters: Any,
        entity_id: Any,
        return_addrs: Optional[list[Any]] = ...,
        outstanding_queries: Optional[dict[str, Any]] = ...,
        timeslack: int = ...,
        asynchop: bool = ...,
        allow_unsolicited: bool = ...,
        test: bool = ...,
        allow_unknown_attributes: bool = ...,
        want_assertions_signed: bool = ...,
        want_assertions_or_response_signed: bool = ...,
        want_response_signed: bool = ...,
        conv_info: Optional[dict[str, Any]] = ...,
        **kwargs: Any
    ) -> None: ...
    def check_subject_confirmation_in_response_to(self, irp: Any) -> bool: ...
    def loads(
        self, xmldata: Union[str, six.binary_type], decode: bool = ..., origxml: Optional[str] = ...
    ) -> AuthnResponse: ...
    def clear(self) -> None: ...
    def authn_statement_ok(self, optional: bool = ...) -> bool: ...
    def condition_ok(self, lax: bool = ...) -> bool: ...
    def decrypt_attributes(self, attribute_statement: AttributeStatement, keys: Optional[Any] = ...) -> None: ...
    def read_attribute_statement(self, attr_statem: AttributeStatement) -> dict[str, Any]: ...
    def get_identity(self) -> dict[str, Any]: ...
    def get_subject(self, keys: Optional[Any] = ...) -> str: ...
    def decrypt_assertions(
        self, encrypted_assertions: list[Any], decr_txt: str, issuer: Optional[str] = ..., verified: bool = ...
    ) -> list[Assertion]: ...
    def find_encrypt_data_assertion(self, enc_assertions: list[Any]) -> Optional[bool]: ...
    def find_encrypt_data_assertion_list(self, _assertions: list[Assertion]) -> Optional[bool]: ...
    def find_encrypt_data(self, resp: StatusResponse) -> bool: ...
    def parse_assertion(self, keys: Optional[Any] = ...) -> bool: ...
    def verify(self, keys: Optional[Any] = ...) -> Optional[AuthnResponse]: ...
    def session_id(self) -> Any: ...
    def id(self) -> Any: ...
    def authn_info(self) -> list[tuple[str, list[str], Any]]: ...
    def authz_decision_info(self) -> dict[str, list[Any]]: ...
    def session_info(self) -> dict[str, Any]: ...
    def verify_recipient(self, recipient: str) -> bool: ...
    def verify_attesting_entity(self, subject_confirmation: SubjectConfirmation) -> bool: ...

def __getattr__(name: str) -> Any: ...  # incomplete
